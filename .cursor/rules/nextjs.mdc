---
description: Next.js 15 and React 19 specific development patterns and optimizations
globs: src/**/*.tsx, src/**/*.ts, app/**/*.tsx, pages/**/*.tsx
alwaysApply: true
---

# Next.js 15 & React 19 Development Rules

## **App Router Patterns**
- **Use App Router for all new pages and layouts**
- **Implement proper loading.tsx and error.tsx files**
- **Use Server Components by default, Client Components when needed**
- **Leverage React 19 features like use() hook and concurrent features**

```typescript
// ✅ DO: Proper App Router structure
// app/properties/[id]/page.tsx
import { Suspense } from 'react';
import { PropertyDetails } from '@/components/PropertyDetails';
import { PropertySkeleton } from '@/components/PropertySkeleton';

export default async function PropertyPage({ params }: { params: { id: string } }) {
  return (
    <Suspense fallback={<PropertySkeleton />}>
      <PropertyDetails propertyId={params.id} />
    </Suspense>
  );
}

// ❌ DON'T: Mix Pages Router with App Router
// pages/properties/[id].tsx (legacy)
```

## **Server Components Best Practices**
- **Use Server Components for data fetching and static content**
- **Minimize Client Components to interactive elements only**
- **Pass serializable props between Server and Client Components**
- **Use async/await in Server Components for data fetching**

```typescript
// ✅ DO: Server Component for data fetching
async function PropertyList() {
  const properties = await fetchProperties();
  
  return (
    <div>
      {properties.map(property => (
        <PropertyCard key={property.id} property={property} />
      ))}
    </div>
  );
}

// ✅ DO: Client Component for interactivity
'use client';
import { useState } from 'react';

function PropertyFilter() {
  const [filters, setFilters] = useState({});
  // Interactive logic here
}
```

## **React 19 Concurrent Features**
- **Use React.use() for promise handling**
- **Leverage concurrent rendering for better UX**
- **Implement proper error boundaries with React 19 patterns**
- **Use Suspense for data loading states**

```typescript
// ✅ DO: React 19 use() hook for promises
import { use } from 'react';

function PropertyDetails({ propertyPromise }: { propertyPromise: Promise<Property> }) {
  const property = use(propertyPromise);
  
  return <div>{property.address}</div>;
}
```

## **Performance Optimization**
- **Implement proper image optimization with next/image**
- **Use dynamic imports for code splitting**
- **Leverage Next.js caching strategies**
- **Optimize bundle size with proper imports**

```typescript
// ✅ DO: Optimized image loading
import Image from 'next/image';

<Image
  src="/property-image.jpg"
  alt="Property description"
  width={800}
  height={600}
  priority={isAboveFold}
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
/>

// ✅ DO: Dynamic imports for heavy components
const PropertyMap = dynamic(() => import('@/components/PropertyMap'), {
  loading: () => <MapSkeleton />,
  ssr: false
});
```

## **Metadata and SEO**
- **Use generateMetadata for dynamic SEO**
- **Implement proper structured data**
- **Optimize for Core Web Vitals**
- **Use Next.js sitemap generation**

```typescript
// ✅ DO: Dynamic metadata generation
export async function generateMetadata({ params }: { params: { id: string } }) {
  const property = await fetchProperty(params.id);
  
  return {
    title: `${property.address} - Las Vegas Real Estate`,
    description: `${property.bedrooms} bedroom home in ${property.neighborhood}`,
    openGraph: {
      title: property.address,
      description: property.description,
      images: [property.image],
    },
  };
}
```

## **Type Safety**
- **Use strict TypeScript configuration**
- **Define proper types for props and API responses**
- **Use Next.js built-in types**
- **Implement runtime type validation**

```typescript
// ✅ DO: Proper TypeScript usage
interface Property {
  id: string;
  address: string;
  bedrooms: number;
  bathrooms: number;
  price: number;
  images: string[];
}

interface PropertyPageProps {
  params: { id: string };
  searchParams: { [key: string]: string | string[] | undefined };
}

export default async function PropertyPage({ params, searchParams }: PropertyPageProps) {
  // Implementation
}
```

## **Error Handling**
- **Implement proper error boundaries**
- **Use error.tsx files for error handling**
- **Handle API errors gracefully**
- **Provide meaningful error messages**

```typescript
// ✅ DO: Error boundary implementation
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

## **State Management**
- **Use React 19 built-in state management**
- **Implement proper context patterns**
- **Use Zustand for complex state**
- **Minimize prop drilling**

```typescript
// ✅ DO: Modern state management
'use client';
import { create } from 'zustand';

interface PropertyStore {
  filters: PropertyFilters;
  setFilters: (filters: PropertyFilters) => void;
}

const usePropertyStore = create<PropertyStore>((set) => ({
  filters: {},
  setFilters: (filters) => set({ filters }),
}));
```

## **API Routes**
- **Use App Router API routes**
- **Implement proper error handling**
- **Use TypeScript for request/response types**
- **Add proper validation**

```typescript
// ✅ DO: App Router API route
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    const properties = await fetchProperties();
    return NextResponse.json(properties);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch properties' },
      { status: 500 }
    );
  }
}
```

## **Security Best Practices**
- **Validate all inputs**
- **Use proper authentication**
- **Implement CSRF protection**
- **Sanitize user-generated content**

## **Testing Patterns**
- **Use React Testing Library for components**
- **Test API routes with proper mocking**
- **Implement integration tests**
- **Use Playwright for E2E testing**

## **Build and Deployment**
- **Use Vercel for deployment**
- **Implement proper environment variables**
- **Use Next.js analytics**
- **Optimize for Core Web Vitals**